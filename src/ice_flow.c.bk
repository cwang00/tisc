
int Ice_Flow(float **velx_sl, float **vely_sl, float dt_ice, float *total_ice_melt, float *total_ice_accum)
{
	/*
	  CALCULATES ICE FLOW AND TRANSPORT.
	  Formulation taken from braun et al., 2003.
	*/
	int	i, j;
	float 	**dh, **dhl, **velx, **vely, **velx_df, **vely_df, **icetopo, densice=920;

	*total_ice_melt=*total_ice_accum = 0;

	if (!K_ice_eros) return(0);

	/*ice flow velocity field*/
	icetopo = alloc_matrix(Ny, Nx);
	for (i=0; i<Ny; i++) for (j=0; j<Nx; j++) {
		icetopo[i][j] = topo[i][j] + ice_thickness[i][j];
		/*printf("\n> %2d %2d icetopo=%6.2f,%.2f", i, j, icetopo[i][j]);*/
	}
	velx    = alloc_matrix(Ny-1, Nx-1);
	vely    = alloc_matrix(Ny-1, Nx-1);
	velx_df = alloc_matrix(Ny-1, Nx-1);
	vely_df = alloc_matrix(Ny-1, Nx-1);
	/*ice velocity field is evaluated in a intermediate grid.  i,j=2,2 is actually 2.5,2.5*/
	for (i=0; i<Ny-1; i++) for (j=0; j<Nx-1; j++) {
		float 	kc = 1e5 /*[m]*/, 
			A_ice_rheo = 2.5e-16/secsperyr   /*m6/s/N3 */, 
			A_sl       = 1.9*1e-10/secsperyr /*m7/s/N-3*/, 
			vel_df, vel_sl, mean_ice_thick, curvtopoxx, curvtopoyy, 
			beta, kvel_df, kvel_sl, gradicetopox, gradicetopoy, modgradicetopo, K_common; 
		int 	il, jl, 
			n_ice_rheo=3;
		/*gradient of bedrock topography and curvature of ice surface topography.  i,j=2,2 is actually 2.5,2.5*/
		gradicetopox = (icetopo[i][j+1]-icetopo[i][j]   + icetopo[i+1][j+1]-icetopo[i+1][j]  )  /2/dx;
		gradicetopoy = (icetopo[i][j]  -icetopo[i+1][j] + icetopo[i][j+1]  -icetopo[i+1][j+1])  /2/dy;
		il=i; jl=j; 
		if (il==0)    il = 1;		if (il==Ny-2) il = Ny-3;
		if (jl==0)    jl = 1;		if (jl==Nx-2) jl = Nx-3;
		curvtopoxx = (topo[il][jl+2]  -topo[il][jl+1]  -topo[il][jl]   +topo[il][jl-1])/dx/dx;
		curvtopoyy = (topo[il-1][jl]  -topo[il][jl]    -topo[il+1][jl] +topo[il+2][jl])/dy/dy;
		/*ice constriction factor depending on the topo curvature perpendicular to ice flow.*/
		modgradicetopo = sqrt(gradicetopox*gradicetopox + gradicetopoy*gradicetopoy);
		beta = (modgradicetopo)? 1 / (1+kc*MAX_2(curvtopoxx*fabs(-gradicetopoy) + curvtopoyy*fabs(gradicetopox), 0)/modgradicetopo) : 1;
		mean_ice_thick = (ice_thickness[i][j]+ice_thickness[i+1][j]+ice_thickness[i][j+1]+ice_thickness[i+1][j+1])/4;
		K_common = beta*pow(densice*g*mean_ice_thick,n_ice_rheo-1) * pow(modgradicetopo,n_ice_rheo-1);
		kvel_df = -2*A_ice_rheo/(n_ice_rheo+2) * K_common * densice*g*pow(mean_ice_thick,2);
		kvel_sl =  - A_sl/.8 * K_common ;
		if (TEMPERATURE(topo[i][j])<8.7e-4*mean_ice_thick) kvel_sl = 0;
		/*ice deformation and sliding velocities, both parallel to icetopo gradient*/
		velx_df[i][j] = kvel_df * gradicetopox; 
		vely_df[i][j] = kvel_df * gradicetopoy; 
		velx_sl[i][j] = kvel_sl * gradicetopox; 
		vely_sl[i][j] = kvel_sl * gradicetopoy; 
		/*Limit velocities to 1/2 of dx*/
		vel_df = sqrt(velx_df[i][j]*velx_df[i][j]+vely_df[i][j]*vely_df[i][j]);
		if (vel_df > (.2*dx/dt_ice)) {
			velx_df[i][j] /= vel_df/(.2*dx/dt_ice) ;
			vely_df[i][j] /= vel_df/(.2*dx/dt_ice) ;
		}
		vel_sl = sqrt(velx_sl[i][j]*velx_sl[i][j]+vely_sl[i][j]*vely_sl[i][j]);
		if (vel_sl > (.2*dx/dt_ice)) {
			velx_sl[i][j] /= vel_sl/(.2*dx/dt_ice) ;
			vely_sl[i][j] /= vel_sl/(.2*dx/dt_ice) ;
		}
		velx[i][j] = velx_df[i][j] + velx_sl[i][j];
		vely[i][j] = vely_df[i][j] + vely_sl[i][j];
		/*printf("\n$ %2d.5 %2d.5  h=%4.0f   gradicetopo=%6.2f,%.2f   curvtopo=%.2e,%.2e  \tbeta=%.2e  vel=%.2f,%.2f  kveld=%.2e", i, j, mean_ice_thick, gradicetopox, gradicetopoy, curvtopoxx, curvtopoyy, beta, velx[i][j]*secsperyr, vely[i][j]*secsperyr, kvel_df);*/
	}

	/*new ice thickness in the original grid*/
	dh = alloc_matrix(Ny, Nx);
	dhl = alloc_matrix(Ny, Nx);
	for (i=0; i<Ny; i++) for (j=0; j<Nx; j++) {
		int 	il, jl;
		float ice_accumulation, ice_melting, ice_thermal_diff=1.09e-6 /*m2/s*/, 
			surf_heat_flow=54e-3 /*W/m2*/, ice_thermal_conduc=2.1 /*W/m/K*/, 
			surf_temp_grad, Ts, Tb, meanvelslx, meanvelsly, ablation_constant=.5, 
			dvelxdx, dvelydy, gradicetopox, gradicetopoy; 
		il=i; jl=j;
		if (i==0)    il = 1;		if (j==0)    jl = 1;
		if (i==Ny-1) il = Ny-2;		if (j==Nx-1) jl = Nx-2;
		meanvelslx = (velx_sl[il][jl] + velx_sl[il][jl-1] + velx_sl[il-1][jl] + velx_sl[il-1][jl-1]) / 4; 
		meanvelsly = (vely_sl[il][jl] + vely_sl[il][jl-1] + vely_sl[il-1][jl] + vely_sl[il-1][jl-1]) / 4;
		gradicetopox = (icetopo[il][jl+1]-icetopo[il][jl-1]) /2/dx;
		gradicetopoy = (icetopo[il-1][jl]-icetopo[il+1][jl]) /2/dy;
		ice_accumulation = Precipitation(i,j,2); 
		*total_ice_accum += ice_accumulation*dx*dy;
		surf_temp_grad = surf_heat_flow/ice_thermal_conduc  +  ice_thickness[i][j]*densice*g*(meanvelslx*gradicetopox+meanvelsly*gradicetopoy)/ice_thermal_conduc;
		Ts = TEMPERATURE(icetopo[i][j]); /*[C]*/
		if (ice_thickness[i][j] && ice_accumulation) {
			float sqrt_term;
			sqrt_term = sqrt(2*ice_thickness[i][j]*ice_thermal_diff/ice_accumulation);
			Tb = Ts + surf_temp_grad * sqrt(3.1415927)/2 * sqrt_term * erf(ice_thickness[i][j]/sqrt_term); /*[C]*/
		}
		else {
			Tb = Ts + surf_temp_grad * ice_thickness[i][j] ;
		}
		/*printf("\n! %2d %2d\ticetopo=%8.2f\th=%8.2f\tdvel=%6.2e,%6.2e\tTs=%.2f\tTb=%.2f\tstg=%.2f", i, j, icetopo[i][j], ice_thickness[i][j], dvelxdx, dvelydy, Ts, Tb, surf_temp_grad);*/
		/*ice melting at the base of the ice, proportional to basal temperature in centigrades*/
		ice_melting = ablation_constant * (Tb+8.7e-4*ice_thickness[i][j]) / secsperyr; 
		ice_melting = MAX_2(0,ice_melting);
		dvelxdx =  ( velx[il][jl] - velx[il][jl-1] + velx[il-1][jl] - velx[il-1][jl-1] )  /2/dx;
		dvelydy =  ( vely[il-1][jl] - vely[il][jl] + vely[il-1][jl-1] - vely[il][jl-1] )  /2/dy;
		if (dvelxdx+dvelydy>=0) { /*extension*/
			dh[i][j] =  (-ice_thickness[i][j]*(dvelxdx+dvelydy) + ice_accumulation - ice_melting) * dt_ice;
			dhl[i][j] = ( -ice_sed_load[i][j]*(dvelxdx+dvelydy) ) * dt_ice;
		}
		if (dvelxdx+dvelydy<0) {  /*convergence*/
			float incomming_ice_thick=0, incomming_sed_thick=0, meanvelx, meanvely, weight, total_weight=0;
			meanvelx = (velx[il][jl] + velx[il][jl-1] + velx[il-1][jl] + velx[il-1][jl-1]) / 4; 
			meanvely = (vely[il][jl] + vely[il][jl-1] + vely[il-1][jl] + vely[il-1][jl-1]) / 4;
			if (dvelxdx<0) {
				if (meanvelx>0){
					incomming_ice_thick += ice_thickness[il][jl-1] * fabs(meanvelx);
					incomming_sed_thick +=  ice_sed_load[il][jl-1] * fabs(meanvelx);
				}
				else {
					incomming_ice_thick += ice_thickness[il][jl+1] * fabs(meanvelx);
					incomming_sed_thick +=  ice_sed_load[il][jl+1] * fabs(meanvelx);
				}
				total_weight += fabs(meanvelx);
			}
			if (dvelydy<0) {
				if (meanvely>0) {
					incomming_ice_thick += ice_thickness[il+1][jl] * fabs(meanvely);
					incomming_sed_thick +=  ice_sed_load[il+1][jl] * fabs(meanvely);
				}
				else {
					incomming_ice_thick += ice_thickness[il-1][jl] * fabs(meanvely);
					incomming_sed_thick +=  ice_sed_load[il-1][jl] * fabs(meanvely);
				}
				total_weight += fabs(meanvely);
			}
			if (total_weight) {
				incomming_ice_thick /= total_weight;
				incomming_sed_thick /= total_weight;
			}
			else 	incomming_ice_thick = incomming_sed_thick = 0;
			dh[i][j] =  (-incomming_ice_thick*(dvelxdx+dvelydy) + ice_accumulation - ice_melting) * dt_ice;
			dhl[i][j] = (-incomming_sed_thick*(dvelxdx+dvelydy)) * dt_ice;
			/*printf("\n! %2d %2d\tdh=%8.2f\th=%8.2f\tdvel=%6.2e,%6.2e\tTs=%.2f\tTb=%.2f\ticeac=%.2f\ticemel=%.2f\tincice=%.2f\tmeanvelx=%.3f\tmeanvely=%.3f", i, j, dh[i][j], ice_thickness[i][j], dvelxdx, dvelydy, Ts, Tb, ice_accumulation*dt_ice, ice_melting*dt_ice, incomming_ice_thick, meanvelx, meanvely);*/
		}
		/*limit the amount of thinning to the available ice thickness*/
		if (dh[i][j] <-ice_thickness[i][j])  {
			ice_melting -= (-dh[i][j]-ice_thickness[i][j])/dt_ice;
			dh[i][j]  = -ice_thickness[i][j];
		}
		if (dhl[i][j]<-ice_sed_load[i][j]) {
			dhl[i][j] = -ice_sed_load[i][j];
		}
		drainage[i][j].discharge += ice_melting*dx*dy;
		*total_ice_melt += ice_melting*dx*dy;
		/*printf("\n* %2d %2d\th=%.2f\tTs=%.2f\tTb=%.2f\ticeac=%.2f\ticemel=%.2f", i, j, ice_thickness[i][j], Ts, Tb, ice_accumulation*dt_ice, ice_melting*dt_ice);*/
	}
	{
		float ice_sed_vol_incr=0, ice_sed_vol=0;
		for (i=0; i<Ny; i++) for (j=0; j<Nx; j++) {
		    ice_sed_vol_incr += dhl[i][j];
		    ice_sed_vol += ice_sed_load[i][j];
		}
		if (fabs(ice_sed_vol_incr)>10*ice_sed_vol/100) fprintf(stderr, "\nERROR in ice deformation: sediment unbalance: %.2e N (%+.2f %%) out of %.2e N", ice_sed_vol_incr*dx*dy*denscrust*g, ice_sed_vol_incr/ice_sed_vol*100, ice_sed_vol*dx*dy*denscrust*g);
	}
	for (i=0; i<Ny; i++) for (j=0; j<Nx; j++) {
		ice_thickness[i][j] += dh[i][j];
		ice_sed_load[i][j] += dhl[i][j];
		/*isostatic compensation of ice load*/
		Dq[i][j] += g * dh[i][j] * (densice - densenv);
		/*check that ice and seds have >0 thickness*/
		if (ice_thickness[i][j]<0 || ice_sed_load[i][j]<0) printf("\nERROR @ %2d,%2d\tice thickness=%8.2f m\tsed. thick.=%8.2fm", i, j, ice_thickness[i][j], ice_sed_load[i][j]);
	}

	free_matrix(dh, Ny);
	free_matrix(dhl, Ny);
	free_matrix(velx, Ny-1);
	free_matrix(vely, Ny-1);
	free_matrix(velx_df, Ny-1);
	free_matrix(vely_df, Ny-1);
	free_matrix(icetopo, Ny);
	return (1);
}

